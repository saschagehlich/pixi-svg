{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/SVG.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","pixiSvg","min","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","_dPathParser","_pixi","measureColor","document","createElement","SVG","svg","_classCallCheck","_this","_possibleConstructorReturn","_PIXI$Graphics","fill","svgChildren","children","inherit","arguments","undefined","child","nodeName","toLowerCase","svgPath","svgCircle","svgRect","svgPoly","hex","substr","parseInt","style","color","rgb","getComputedStyle","body","appendChild","match","map","removeChild","isEllipse","heightProp","widthProp","width","parseFloat","node","getAttribute","height","cx","cy","x","y","drawEllipse","drawCircle","rx","drawRoundedRect","drawRect","opacity","stroke","strokeWidth","split","forEach","prop","_prop$split","name","value","result","trim","drawPolygon","points","closePath","_svgStyle","defaultLineWidth","lineWidth","beginFill","hexToUint","lineStyle","lineColor","prototype","d","commands","_dPathParser2","default","command","moveTo","end","lineTo","currX","currY","bezierCurveTo","cp1","cp2","_currX","_currY","_currX2","_currY2","quadraticCurveTo","cp","_currX3","_currY3","_pixi2","Graphics","d-path-parser","pixi.js","2","_interopRequireDefault","__esModule","_SVG","_SVG2"],"mappings":";;;;;;;CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,MAAAJ,EAAAK,UAAAL,EAAAK,aAAAC,IAAAX,MAAA,WAAA,MAAA,YAAA,QAAAY,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAjB,GAAA,IAAAc,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAC,GAAA,kBAAAC,UAAAA,OAAA,KAAAnB,GAAAkB,EAAA,MAAAA,GAAAD,GAAA,EAAA,IAAAG,EAAA,MAAAA,GAAAH,GAAA,EAAA,IAAAI,GAAA,GAAAC,OAAA,uBAAAL,EAAA,IAAA,MAAAI,GAAAE,KAAA,mBAAAF,EAAA,GAAAG,GAAAV,EAAAG,IAAAhB,WAAAY,GAAAI,GAAA,GAAAQ,KAAAD,EAAAvB,QAAA,SAAAW,GAAA,MAAAI,GAAAH,EAAAI,GAAA,GAAAL,IAAAA,IAAAY,EAAAA,EAAAvB,QAAAW,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAhB,QAAA,IAAA,GAAAmB,GAAA,kBAAAD,UAAAA,QAAAF,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,GAAA,MAAAJ,OAAAe,GAAA,SAAAR,EAAAjB,EAAAD,8oBCAA,IAAA2B,GAAAT,EAAA,wBACAU,EAAAV,EAAA,kBAIMW,EAAeC,SAASC,cAAc,OASvBC,cAIjB,QAAAA,GAAaC,GAAKC,EAAA1B,KAAAwB,EAAA,IAAAG,GAAAC,EAAA5B,KACd6B,EAAAb,KAAAhB,MADc,OAEd2B,GAAKG,KAAKL,GACVE,EAAKI,YAAYN,EAAIO,UAHPL,EA8UI,0BAjUtBI,qBAAaC,GACT,IAAK,GADcC,GAAiBC,UAAAjB,OAAA,OAAAkB,KAAAD,UAAA,IAAAA,UAAA,GAC3B1B,EAAI,EAAGA,EAAIwB,EAASf,OAAQT,IAAK,CACtC,GAAM4B,GAAQJ,EAASxB,EAEvB,QADAR,KAAK8B,KAAKM,EAAOH,GACTG,EAAMC,SAASC,eACnB,IAAK,OACDtC,KAAKuC,QAAQH,EACb,MAEJ,KAAK,SACL,IAAK,UACDpC,KAAKwC,UAAUJ,EACf,MAEJ,KAAK,OACDpC,KAAKyC,QAAQL,EACb,MAEJ,KAAK,UACDpC,KAAK0C,QAAQN,GAAO,EACpB,MAEJ,KAAK,WACDpC,KAAK0C,QAAQN,GAUbpC,KAAA+B,YAAAK,EAAAJ,UAAA,qDAkBR,SANRW,EAAAC,UAGQ,IAAAD,EAAM1B,6CAGF4B,SAAAF,EAAJ,GAECtB,GAAAyB,MAAAC,MAAAJ,CACD,IAAAK,GAAOnD,OAASoD,iBAAhB3B,SAAA4B,KAAAC,YAAA9B,IAAA0B,MAAAK,MAAA,QAAAC,IAAA,SAAAzC,GACG,MAAAiC,UAAAjC,EAAA,KAKK,OAHRU,UAAM4B,KAAMI,YAAOjC,IAGX2B,EAAO,IAAA,KAAAA,EAAP,IAAA,GAAAA,EAAA,kDAahB,2BAEQO,KACAC,GAAY,IACVC,GAAY,IAEd,IAAAC,GAAAC,WAAAC,EAAAC,aAAAJ,IACAK,EAAAH,WAAAC,EAAAC,aAAAL,IACHO,EAAAH,EAAAC,aAAA,MACKG,EAAAJ,EAAQC,aAAW,MACnBI,EAAA,EACAC,EAAA,CACK,QAALH,IACFE,EAAIN,WAARI,IAEW,OAAPC,IACAE,EAAIP,WAAWK,IAEfT,EAGAvD,KAACmE,YAAWF,EAAAC,EAAAR,EAAAI,GAFZ9D,KAAIoE,WAAWH,EAAfC,EAAAR,8GAgBRC,oCACUG,EAAIH,WAAgBC,EAAAC,aAA1B,WACMQ,EAAIV,WAAWC,EAAKC,aAAa,MACjCQ,GACArE,KAAAsE,gBAAoBL,EAAAC,EAAKR,EAAAI,EAAaO,GAExCrE,KAAIuE,SAAAN,EAAAC,EAAAR,EAAAI,2EAyBZF,EAAAC,qBACUW,QAAQZ,EAAKC,aAAa,WAC1BY,OAAAb,EAASC,aAAA,UACXa,YAAWd,EAAAC,aADA,gBAaP,OAVI,QAARf,IACAA,EAAA6B,MAAA,KAAaC,QAAK,SAAaC,GAJnC,GAAAC,GAAAD,EAAAF,MAAA,KAMII,EAAJD,EAAoB,GACVE,EAANF,EAAyB,EAAQG,GACtBF,EADsBG,QAAAF,EAAAE,6BAE7BD,EAAOP,YAAPO,EAA4B,sBAFhCA,GAAA,kBAMIA,yGAYZpC,cAIa7C,MAAAmF,YAAKC,MAEdpF,KAAKqF,wFAcYZ,EAAAa,EAEiCb,OAA3CC,EAFUY,EAAAZ,YAEKa,EAFL,OAEKd,EAFL,EAAA,EAEae,EAAA,OAFbd,EAAAf,WAAAe,GAAAa,6CAGXzD,GACY,SAAZA,EACA9B,KAAAyF,UAAY,EAAA,GAEVzF,KAAAyF,UAAJzF,KAAqB0F,UAAA5D,GAAA,OAAA0C,EAAAb,WAAAa,GAAA,GAEdvC,GACHjC,KAAAyF,UAAK,GAKZzF,KATD2F,UASYH,EAASI,IAcpBpE,EAAAqE,UAAAtD,QAAA,SAAAqB,UACGkC,GAAAlC,EAAKC,aAAa,KAClBI,MAAA,GACHC,MAAA,GACD6B,GAAA,EAAAC,EAAAC,SAAAH,iCAGJ,QAAAI,EAAApF,+DAMmBd,KAAAmG,OAAalC,EAA5BiC,EAAAE,IAAAnC,EAAAC,EAAAgC,EAAAE,IAAAlC,EACA,MACM,KAAA,IAEIlE,KAAUqG,OAAApC,EAAhBiC,EAAAlB,MAAAd,EACQ,MACM,KAAA,IAKNlE,KAAAqG,OAAApC,GAAAiC,EAAAlB,MAAAd,EACH,MACS,KAAA,IAKNlE,KAAAqG,OAAApC,EAAAC,EAAAgC,EAAAlB,MACH,MACS,KAAA,IAENhF,KAAAqG,OAAApC,EAAAC,GAAAgC,EAAAlB,MACH,MACS,KAAA,IAENhF,KAAAqF,WACH,MACS,KAAA,IAENrF,KAAAqG,OAAApC,EAAAiC,EAAAE,IAAAnC,EAAAC,EAAAgC,EAAAE,IAAAlC,EACH,MACS,KAAA,IAENlE,KAAAqG,OAAApC,GAAAiC,EAAAE,IAAAnC,EAAAC,GAAAgC,EAAAE,IAAAlC,EACH,MACS,KAAA,IAEN,GAAAoC,GAAArC,EACHsC,EAAArC,CACDlE,MAAAwG,cAAAF,EAAAJ,EAAAO,IAAAxC,EAAAsC,EAAAL,EAAAO,IAAAvC,EAAAoC,EAAAJ,EAAAQ,IAAAzC,EAAAsC,EAAAL,EAAAQ,IAAAxC,EAAAD,EAAAiC,EAAAE,IAAAnC,EAAAC,EAAAgC,EAAAE,IAAAlC,EAAU,MAKN,KAAA,IAEJ,GAAAyC,GAAA1C,EAAU2C,EAAA1C,CACNlE,MAAKwG,cACIG,EAAAT,EACLO,IAAKxC,EAAA2C,EAFTV,EAAAO,IAAAvC,EAAAyC,EAAAT,EAAAQ,IAAAzC,EAAA2C,EAAAV,EAAAQ,IAAAxC,EAAAD,GAAAiC,EAAAE,IAAAnC,EAAAC,GAAAgC,EAAAE,IAAAlC,EAIA,MAEJ,KAAK,IAAK,IAAA,IAEN,GAAM2C,GAAN5C,EACA6C,EAAK5C,CAQLlE,MAAA+G,iBAAAF,EAAAX,EAAAc,GAAA/C,EAAA6C,EAAAZ,EAAAc,GAAA9C,EAAAD,GAAAiC,EAAAE,IAAAnC,EAAAC,GAAAgC,EAAAE,IAAAlC,EACH,MACS,KAAA,IACN,IAAA,IAEA,GAAA+C,GAAKhD,EAQLiD,EAAAhD,CACHlE,MAAA+G,iBAAAE,EAAAf,EAAAc,GAAA/C,EAAAiD,EAAAhB,EAAAc,GAAA9C,EAAAD,EAAAiC,EAAAE,IAAAnC,EAAAC,EAAAgC,EAAAE,IAAAlC,MAcS1C,GACN2F,EAAAlB,QAAAmB,SAEA5H,GAAAyG,QAAAzE,IAOH6F,oBAAAlF,GAAAmF,cAAAnF,KAAAoF,GAAA,SAAA7G,EAAAjB,EAAAD,GACD,qBA7ViBgI,2CA8VbhI,EAAAiI,YAAA,CAEA,IAAAC,GAAAhH,EAAA,SAEHiH,EAAAH,EAAAE,GAERtG,EAAAV,EAAA","file":"pixi-svg.min.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","import dPathParse from 'd-path-parser';\nimport PIXI from 'pixi.js';\n\n// <div> element to measure string colors like \"black\"\n// and convert to hex colors\nconst measureColor = document.createElement('div');\n\n/**\n * Scalable Graphics drawn from SVG image document.\n * @class SVG\n * @extends PIXI.Graphics\n * @memberof PIXI\n * @param {SVGSVGElement} svg - SVG Element `<svg>`\n */\nexport default class SVG extends PIXI.Graphics {\n    /**\n     * Constructor\n     */\n    constructor (svg) {\n        super();\n        this.fill(svg);\n        this.svgChildren(svg.children);\n    }\n\n    /**\n     * Create a PIXI Graphic from SVG element\n     * @private\n     * @method PIXI.SVG#svgChildren\n     * @param {Array<*>} children - Collection of SVG nodes\n     * @param {Boolean} [inherit=false] Whether to inherit fill settings.\n     */\n    svgChildren (children, inherit = false) {\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            this.fill(child, inherit);\n            switch (child.nodeName.toLowerCase()) {\n                case 'path': {\n                    this.svgPath(child);\n                    break;\n                }\n                case 'circle':\n                case 'ellipse': {\n                    this.svgCircle(child);\n                    break;\n                }\n                case 'rect': {\n                    this.svgRect(child);\n                    break;\n                }\n                case 'polygon': {\n                    this.svgPoly(child, true);\n                    break;\n                }\n                case 'polyline': {\n                    this.svgPoly(child);\n                    break;\n                }\n                case 'g': {\n                    break;\n                }\n                default: {\n                    // @if DEBUG\n                    console.info('[SVGUtils] <%s> elements unsupported', child.nodeName);\n                    // @endif\n                    break;\n                }\n            }\n            this.svgChildren(child.children, true);\n        }\n    }\n\n    /**\n     * Convert the Hexidecimal string (e.g., \"#fff\") to uint\n     * @private\n     * @method PIXI.SVG#hexToUint\n     */\n    hexToUint (hex) {\n        if (hex[0] === '#') {\n                        // Remove the hash\n            hex = hex.substr(1);\n\n                        // Convert shortcolors fc9 to ffcc99\n            if (hex.length === 3) {\n                hex = hex.replace(/([a-f0-9])/ig, '$1$1');\n            }\n            return parseInt(hex, 16);\n        } else {\n            measureColor.style.color = hex;\n            const rgb = window.getComputedStyle(document.body.appendChild(measureColor)).color\n                .match(/\\d+/g)\n                .map(function (a) {\n                    return parseInt(a, 10);\n                });\n            document.body.removeChild(measureColor);\n            return (rgb[0] << 16) + (rgb[1] << 8) + rgb[2];\n        }\n    }\n\n    /**\n     * Render a <ellipse> element or <circle> element\n     * @private\n     * @method PIXI.SVG#internalEllipse\n     * @param {SVGCircleElement} node\n     */\n    svgCircle (node) {\n\n        let heightProp = 'r';\n        let widthProp = 'r';\n        const isEllipse = node.nodeName === 'elipse';\n        if (isEllipse) {\n            heightProp += 'x';\n            widthProp += 'y';\n        }\n        const width = parseFloat(node.getAttribute(widthProp));\n        const height = parseFloat(node.getAttribute(heightProp));\n        const cx = node.getAttribute('cx');\n        const cy = node.getAttribute('cy');\n        let x = 0;\n        let y = 0;\n        if (cx !== null) {\n            x = parseFloat(cx);\n        }\n        if (cy !== null) {\n            y = parseFloat(cy);\n        }\n        if (!isEllipse) {\n            this.drawCircle(x, y, width);\n        }\n        else {\n            this.drawEllipse(x, y, width, height);\n        }\n    }\n\n    /**\n     * Render a <rect> element\n     * @private\n     * @method PIXI.SVG#svgRect\n     * @param {SVGRectElement} node\n     */\n    svgRect (node) {\n        const x = parseFloat(node.getAttribute('x'));\n        const y = parseFloat(node.getAttribute('y'));\n        const width = parseFloat(node.getAttribute('width'));\n        const height = parseFloat(node.getAttribute('height'));\n        const rx = parseFloat(node.getAttribute('rx'));\n        if (rx) {\n            this.drawRoundedRect(\n                x,\n                y,\n                width,\n                height,\n                rx\n            );\n        } else {\n            this.drawRect(\n                x,\n                y,\n                width,\n                height\n            );\n        }\n    }\n\n    /**\n     * Get the style property and parse options.\n     * @private\n     * @method PIXI.SVG#svgStyle\n     * @param {SVGElement} node\n     * @return {Object} Style attributes\n     */\n    svgStyle (node) {\n        const style = node.getAttribute('style');\n        const result = {\n            fill: node.getAttribute('fill'),\n            opacity: node.getAttribute('opacity'),\n            stroke: node.getAttribute('stroke'),\n            strokeWidth: node.getAttribute('stroke-width')\n        };\n        if (style !== null) {\n            style.split(';').forEach(prop => {\n                const [name, value] = prop.split(':');\n                result[name.trim()] = value.trim();\n            });\n            if (result['stroke-width']) {\n                result.strokeWidth = result['stroke-width'];\n                delete result['stroke-width'];\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Render a polyline element.\n     * @private\n     * @method PIXI.SVG#svgPoly\n     * @param {SVGPolylineElement} node\n     */\n    svgPoly (node, close) {\n\n        const points = node.getAttribute('points')\n            .split(/[ ,]/g)\n            .map(p => parseInt(p));\n\n        this.drawPolygon(points);\n\n        if (close) {\n            this.closePath();\n        }\n    }\n\n    /**\n     * Set the fill and stroke style.\n     * @private\n     * @method PIXI.SVG#fill\n     * @param {SVGElement} node\n     * @param {Boolean} inherit\n     */\n    fill (node, inherit) {\n\n        const {fill, opacity, stroke, strokeWidth} = this.svgStyle(node);\n        const defaultLineWidth = stroke !== null ? 1 : 0;\n        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : defaultLineWidth;\n        const lineColor = stroke !== null ? this.hexToUint(stroke) : this.lineColor;\n        if (fill) {\n            if (fill === 'none') {\n                this.beginFill(0, 0);\n            } else {\n                this.beginFill(\n                    this.hexToUint(fill),\n                    opacity !== null ? parseFloat(opacity) : 1\n                );\n            }\n        } else if (!inherit) {\n            this.beginFill(0);\n        }\n        this.lineStyle(\n            lineWidth,\n            lineColor\n        );\n\n        // @if DEBUG\n        if (node.getAttribute('stroke-linejoin')) {\n            console.info('[SVGUtils] \"stroke-linejoin\" attribute is not supported');\n        }\n        if (node.getAttribute('stroke-linecap')) {\n            console.info('[SVGUtils] \"stroke-linecap\" attribute is not supported');\n        }\n        if (node.getAttribute('fill-rule')) {\n            console.info('[SVGUtils] \"fill-rule\" attribute is not supported');\n        }\n        // @endif\n    }\n\n    /**\n     * Render a <path> d element\n     * @method PIXI.SVG#svgPath\n     * @param {SVGPathElement} node\n     */\n    svgPath (node) {\n        const d = node.getAttribute('d');\n        let x, y;\n        const commands = dPathParse(d);\n        for (var i = 0; i < commands.length; i++) {\n            const command = commands[i];\n            switch (command.code) {\n                case 'm': {\n                    this.moveTo(\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'M': {\n                    this.moveTo(\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'H': {\n                    this.lineTo(x = command.value, y);\n                    break;\n                }\n                case 'h': {\n                    this.lineTo(x += command.value, y);\n                    break;\n                }\n                case 'V': {\n                    this.lineTo(x, y = command.value);\n                    break;\n                }\n                case 'v': {\n                    this.lineTo(x, y += command.value);\n                    break;\n                }\n                case 'Z': {\n                    this.closePath();\n                    break;\n                }\n                case 'L': {\n                    this.lineTo(\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'l': {\n                    this.lineTo(\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'C': {\n                    const currX = x;\n                    const currY = y;\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                case 'c': {\n                    const currX = x;\n                    const currY = y;\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 's':\n                case 'q': {\n                    const currX = x;\n                    const currY = y;\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x += command.end.x,\n                        y += command.end.y\n                    );\n                    break;\n                }\n                case 'S':\n                case 'Q': {\n                    const currX = x;\n                    const currY = y;\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x = command.end.x,\n                        y = command.end.y\n                    );\n                    break;\n                }\n                default: {\n                    // @if DEBUG\n                    console.info('[SVGUtils] Draw command not supported:', command.code, command);\n                    // @endif\n                    break;\n                }\n            }\n        }\n    }\n}\n"],"sourceRoot":"."}